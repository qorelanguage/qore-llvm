//--------------------------------------------------------------------*- C++ -*-
//
//  Qore Programming Language
//
//  Copyright (C) 2015 Qore Technologies
//
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//
//------------------------------------------------------------------------------
///
/// \file
/// \brief A Source filter that removes comments.
///
//------------------------------------------------------------------------------
#ifndef INCLUDE_QORE_PDP_COMMENTSTRIPPER_H_
#define INCLUDE_QORE_PDP_COMMENTSTRIPPER_H_

#include "qore/common/Util.h"
#include "qore/context/DiagManager.h"
#include "qore/context/Source.h"

namespace qore {
namespace pdp {

/**
 * \brief Removes comments from a Source.
 *
 * Preserves all newline characters. Generates a single space character for each block comment to avoid
 * joining two tokens as in `a/&lowast;...&lowast;/b`.
 * \tparam Src the type of the underlying source
 */
template<typename Src = Source>
class CommentStripper {

private:
    enum class State {
        Default, StringSingle, StringDouble, StringDoubleBackslash, BlockComment
    };

public:
    /**
     * \brief Constructor.
     * \param diagMgr for reporting diagnostics (an open block comment at the end of file)
     * \param src the source to remove comments from
     */
    CommentStripper(DiagManager &diagMgr, Src &src) : diagMgr(diagMgr), src(src) {
    }

    /**
     * \brief Returns the location of the next character returned by read().
     *
     * The location of the (non-existent) space character generated by block comments is guaranteed to be
     * inside that block comment, but not necessarily at the start or the end of the comment. The column number
     * of a newline character in any comment is undefined.
     * \return current location in the source
     */
    SourceLocation getLocation() const {
        return src.getLocation();
    }

    /**
     * \brief Reads the next non-comment character from the source.
     * \return the next character read
     */
    int read() {
        switch (state) {
            case State::Default:
                return doDefault();
            case State::StringSingle:
                return doStringSingle();
            case State::StringDouble:
                return doStringDouble();
            case State::StringDoubleBackslash:
                state = State::StringDouble;
                return src.read();
            case State::BlockComment:
                return doBlockComment();
        }
        QORE_UNREACHABLE("Illegal state");
    }

private:
    int doDefault() {
        int c = src.read();
        switch (c) {
            case '\'':
                state = State::StringSingle;
                return c;
            case '"':
                state = State::StringDouble;
                return c;
            case '#':
                while (c != '\n' && c != Source::EndOfFile) {
                    c = src.read();
                }
                return c;
            case '/':
                if (src.peek() != '*') {
                    return c;
                }
                src.read();
                state = State::BlockComment;
                return doBlockComment();
            default:
                return c;
        }
    }

    int doStringSingle() {
        int c = src.read();
        //FIXME #50 single-quoted strings
        if (c == '\'') {
            state = State::Default;
        }
        return c;
    }

    int doStringDouble() {
        int c = src.read();
        if (c == '"') {
            state = State::Default;
        } else if (c == '\\') {
            state = State::StringDoubleBackslash;
        }
        return c;
    }

    int doBlockComment() {
        bool asterisk = false;
        while (true) {
            switch (src.read()) {
                case Source::EndOfFile:
                    diagMgr.report(DiagId::PdpUnendedBlockComment, getLocation());
                    state = State::Default;
                    return Source::EndOfFile;
                case '\n':
                    return '\n';
                case '*':
                    asterisk = true;
                    break;
                case '/':
                    if (asterisk) {
                        state = State::Default;
                        return ' ';
                    }
                    break;
                default:
                    asterisk = false;
                    break;
            }
        }
    }

private:
    DiagManager &diagMgr;
    Lookahead<Src> src;
    State state{State::Default};
};

} // namespace pdp
} // namespace qore

#endif // INCLUDE_QORE_PDP_COMMENTSTRIPPER_H_
